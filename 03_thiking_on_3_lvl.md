Задание начал выполнять во время паузы, по памяти. Меня "озарило" идеей проекта и я начал писать "пару сотен строк" TDD кода, хотя до этого даже боялся приступить.  
В очередной раз, озарение оказалось прямо соответствующим материалам урока; оно касалось больше не "продуктовой" полезности(о какая крутая идея), а моей способности это реализовать, т.е. 3-ий уровень был взят.  
Ранее я начинал замечать(рассматривать) в своих привычных игрушках баги и особенности механики как особенности програмной реализации. И вот, эти разрозненные механики слились воедино.  
Предлагаю обратить внимание, что этот процесс слияния соответствует созданию(!) нового, более абстрактного уровня(слоя) классификатора фичей в искусственных нейронных сетях. Закономерно, что практика TDD - хорошее упражнение.   
Итак, я начал писать игру про бегущих крыс, у которых возникает конкуренция за ресурсы. Для чего мне понадобилася путь, заполненный ячейками с атрибутами.  

def test_init_way(self, length: int, initial_cell: int):  
    list(map(lambda x,y: self.assert_init_way(x, y), way, [initial_cell] * length))  # тут была возможность написать тест, который ничего не проверяет, но я её избежал.  

Усложнив ячейку с совсем простой int с номером, я добавил в неё указатель на функцию - действие и метод "выполнить действие" (заготовка для будущих эвентов).  
И переписав ещё несколько подобных тестов, я пришел прямо к прописанному в заданиях пониманию разработки, движимой логикой - вместо нескольких, формальных тестов у меня остался один, который формально даже не тест.  

def run_actions(self):
    list(map(lambda x: x.do_action(), self.way))  

Но он делает именно то, что должен делать тест - обходит ячейки и запускает действия в них.  
Ещё одно наблюдение к этому опыту читайте в блоге : )  
