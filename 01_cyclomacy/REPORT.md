// является ли разная реализация(у потомков) абстрактного(у родителя) метода корректным примером ad-hoc полиморфизма? 
// то ли я выбрал плохие примеры, то ли еще что, но в двух случаях в 2 раза снизить ЦС не получается. 

### 1.py
ЦС исходная - 8  
ЦС итоговая 4, 4, 1, 1  
Метод (зачем-то обернутый в класс, не стал уже это менять) пробует установить соединение с базой данных и напечатать результат какого-то запроса.  
Исходно неплохо названы переменные, но логика действительно не сразу видна / перемешана.   
Изолировал целевой метод (обращение к базе, печать), заменив цикл for на map.  
Очистил установку соединения от побочных проверок и выводов.  
В итоге получилось проще и понятнее: попытки установки соединения с прерыванием и действие, если соединение установилось. Ушла переменная status, хотя 
в варианте автора это имеет смысл. Т.е. автор неплохо назвал переменную, но это можно было сделать лучше, вообще отказавшись от нее с помощью снижения ЦС(неожиданно). 

### 2.py

ЦС исходная - 6?
ЦС итоговая - 2, 2, 2, 3?
Выбрал модуль, а не функцию / метод и в ней, как оказалось, ЦС считается неправильно (изза стандартного для Python блока if name == __main__, или ещё из-за чего). 
Модуль написан ужасно, выделил методы с ветвлением, удалил логику try-except-finally:  
1. except не обрабатывал ошибку а только выводил сообщение, а оно и так выведется
2. finally выполнится в любом случае (может и не в любом, не вполне понял конструкцию, её конечно же надо запретить в рамках школы)
3. зачем тогда try?
Вынесение методов убирает инициализацию переменных driver, proxy в None, но в конце проверка на None осталась, не уверен как работает метод, поэтому не уверен как её убрать.


### 3.PY

Код из репозитория https://github.com/bintoro/overloading.py - как я понял, чел сделал костыль для полиморфизма подтипов : ) 
ЦС исходная 12
ЦС результат - не получилось
Сначала хотел выделить случаи нужна-ненужна обработка, но они не выделяются, т.к сидят в логике других методов
Потом думал применить параметрический полиморфизм, но опять же, методы возвращают какой-то тип и два вызова с разными аргументами тогда могут вернуть корректное значение, потом все равно придется сравнивать с условием. 


### 4_?.py 

Подходит ли код под "табличную" логику? Вроде задача похожая - обработка токенов внешним regex выражением.  Но непонял что в теории написано к этому, очень короткий абзац. 

### FizzBuzz.py

Думал что for while тоже условные операторы (условие же). 


